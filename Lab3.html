<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      Michael Ostroff <br />
      4/19/25
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This is a sample introduction showcasing how you might structure 
          your opening section. Replace this paragraph with a concise 
          overview of the topic or project you are addressing. You can then 
          expand the explanation as needed.
          This module focused on the Sierpinski triangle as well as cellular automata.
          The Sierpinski triangle is the shape you get if you start with a triangle and
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
# Define the function to draw an equilateral triangle
def color_blend(c1,c2,x):
  return tuple((1-x)*c1[k]+x*c2[k] for k in range(3))
def coord_blend(points,p1,p2,x):
  return tuple((1-x)*points[p1][k]+x*points[p2][k] for k in range(2))
def points_list_gen(points,relSide):
  newpointslist=tuple(coord_blend(points,k,(k+1)%3,relSide[k]) for k in range(3))
  return tuple((points[k],newpointslist[k],newpointslist[(k-1)%3]) for k in range(3))
def sierpinski_triangle4(order,points,relSide,colorInp,colorDecay):
  color(color_rgb(*colorInp))
  penup()
  if order==0:
    color(color_rgb(*colorInp))
    goto(*points[2])
    pendown()
    for k in range(3):
      goto(*points[k])
    penup()
  else:
    points_list=points_list_gen(points,relSide)
    sierpinski_triangle4(order - 1,points_list[0],relSide,color_blend(colorInp,(1,0,0),colorDecay),colorDecay)
    sierpinski_triangle4(order - 1,points_list[1],relSide,color_blend(colorInp,(0,1,0),colorDecay),colorDecay)
    sierpinski_triangle4(order - 1,points_list[2],relSide,color_blend(colorInp,(0,0,1),colorDecay),colorDecay)
initializeTurtle()
#showturtle()

# Set up the turtle
jump(300, 500)
face(90)
bgcolor('black')
color('green')
width(1)
equilateral_points=tuple((500-400*math.sin(2*k*math.pi/3),400-400*math.cos(2*k*math.pi/3)) for k in range(3))
# Draw the Sierpinski triangle
length = 400
order = 8
#order = 1
sierpinski_triangle4(order, equilateral_points,(0.63,0.5,0.37),(1,1,1),0.2)
#hideturtle()
show()
	</code></pre>

<pre><code class="language-python">
# Define the function to draw an equilateral triangle
def color_blend(c1,c2,x):
  return tuple((1-x)*c1[k]+x*c2[k] for k in range(3))
def coord_blend(points,p1,p2,x):
  return tuple((1-x)*points[p1][k]+x*points[p2][k] for k in range(2))
def points_list_gen(points,relSide):
  newpointslist=tuple(coord_blend(points,k,(k+1)%3,relSide[k]) for k in range(3))
  return tuple((points[k],newpointslist[k],newpointslist[(k-1)%3]) for k in range(3))
def sierpinski_triangle5(order,points,randPar,colorInp,colorDecay):
  #color(color_rgb(*colorInp))
  relSide=tuple(0.5+randPar*(2*random.random()-1)/4 for k in range(3))
  penup()
  if order==0:
    color(color_rgb(*colorInp))
    goto(*points[2])
    pendown()
    for k in range(3):
      goto(*points[k])
    penup()
  else:
    points_list=points_list_gen(points,relSide)
    sierpinski_triangle5(order - 1,points_list[0],randPar,color_blend(colorInp,(1,0,0),colorDecay),colorDecay)
    sierpinski_triangle5(order - 1,points_list[1],randPar,color_blend(colorInp,(0,1,0),colorDecay),colorDecay)
    sierpinski_triangle5(order - 1,points_list[2],randPar,color_blend(colorInp,(0,0,1),colorDecay),colorDecay)
initializeTurtle()
#showturtle()

# Set up the turtle
jump(300, 500)
face(90)
bgcolor('black')
color('green')
width(1)
equilateral_points=tuple((500-400*math.sin(2*k*math.pi/3),400-400*math.cos(2*k*math.pi/3)) for k in range(3))
# Draw the Sierpinski triangle
length = 400
order = 8
#order = 1
sierpinski_triangle5(order, equilateral_points,0.3,(1,1,1),0.2)
#hideturtle()
show()
	</code></pre>



      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          In this placeholder section, you might describe observations,
          results, or insights gained from any analysis. You can incorporate 
          references to equations (e.g., $y = mx + b$) or embed images and 
          other visual aids to illustrate your points.
        </p>




        <figure>
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/800px-Mandel_zoom_00_mandelbrot_set.jpg"
            alt="Mandelbrot Broad View"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Figure 1:</strong> A broad view of the Mandelbrot set 
            (max_iter = 100). Colors represent how many iterations were 
            needed to exceed |z|=2.
          </figcaption>
        </figure>




      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this sample conclusion, we highlight how the iterative approach to generating fractals reveals the vast complexity inherent in seemingly simple equations. Through our Python implementation, we observed that small parameter changes can produce markedly different fractal patterns, underscoring the Mandelbrot set's boundless intricacy. Our visualizations not only confirm the self-similarity and infinite resolution of the set, but also underscore the crucial role of computational optimizations in making high-resolution explorations feasible. Ultimately, this lab demonstrates that fractal geometry, far from being mere mathematical curiosities, provides deep insights into pattern formation and complexity in both pure mathematics and broader scientific contexts. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>

<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      Michael Ostroff <br />
      4/15/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          For this module, we used the turtle code to create brownian motion,
          Koch, and dragon fractals. We were then told to play around with the
          code to create our own fractals. I made higher order Koch curves and
          played around with adding randomness to them.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
#Some of the random functions I played around with
def rand1_blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        randVar=random.uniform(-20, 20)
        rand1_blip_line(length / 3, order - 1)
        left(60-randVar)
        rand1_blip_line(length / 3, order - 1)
        right(120)
        rand1_blip_line(length / 3, order - 1)
        left(60+randVar)
        rand1_blip_line(length / 3, order - 1)
def rand2_blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        randVar1=random.uniform(-20, 20)
        randVar2=random.uniform(-20, 20)
        rand2_blip_line(length / 3, order - 1)
        left(60-randVar1)
        rand2_blip_line(length / 3, order - 1)
        right(120+randVar2)
        rand2_blip_line(length / 3, order - 1)
        left(60+randVar1+randVar2)
        rand2_blip_line(length / 3, order - 1)
def rand3_line(length, order):
    if order == 0:
        forward(length)
    else:
        randVar1=random.uniform(-40, 40)
        randVar2=random.uniform(-100, 100)
        rand3_line(length / 3, order - 1)
        left(0-randVar1)
        rand3_line(length / 3, order - 1)
        right(0+randVar2)
        rand3_line(length / 3, order - 1)
        left(0+randVar1+randVar2)
        rand3_line(length / 3, order - 1)
def rand4_line(length, order):
    if order == 0:
        forward(length)
    else:
        randVar1=100*random.uniform(-1, 1)
        randVar2=20*random.uniform(-1, 1)
        rand4_line(length / 3, order - 1)
        left(0-randVar1)
        rand4_line(length / 3, order - 1)
        right(0+randVar2)
        rand4_line(length / 3, order - 1)
        left(0+randVar1+randVar2)
        rand4_line(length / 3, order - 1)
		
	</code></pre>






      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          In this placeholder section, you might describe observations,
          results, or insights gained from any analysis. You can incorporate 
          references to equations (e.g., $y = mx + b$) or embed images and 
          other visual aids to illustrate your points.
	  I discovered something interesting. If the Koch curve is slightly randomized(rand1_blip_line and rand2_blip_line), it still won't intersect itself(at least it doesn't objectively appear to from the perspective of someone who can't zoom in). I decided to experiment with this by removing the bias inherent in the Koch curve and amplifying the randomness. It seems if the total randomness of randVar1 and randVar2 is below 120 degrees, then it seems very risiliant against self intersecting. Not completely sure about this though. It seems despite the randomness, the structure imposed by lower order limits how close elements of different segments can get to each other. This is likely quantifiable, and could be used to prove a lack of self-intersection. If this is the case, one could reliably create coastlines which don't intersect. If seeded randomness was involved, then this could allow this to be converted into a parametric function.
        </p>




        <figure>
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/800px-Mandel_zoom_00_mandelbrot_set.jpg"
            alt="Mandelbrot Broad View"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Figure 1:</strong> A broad view of the Mandelbrot set 
            (max_iter = 100). Colors represent how many iterations were 
            needed to exceed |z|=2.
          </figcaption>
        </figure>




      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this sample conclusion, we highlight how the iterative approach to generating fractals reveals the vast complexity inherent in seemingly simple equations. Through our Python implementation, we observed that small parameter changes can produce markedly different fractal patterns, underscoring the Mandelbrot set's boundless intricacy. Our visualizations not only confirm the self-similarity and infinite resolution of the set, but also underscore the crucial role of computational optimizations in making high-resolution explorations feasible. Ultimately, this lab demonstrates that fractal geometry, far from being mere mathematical curiosities, provides deep insights into pattern formation and complexity in both pure mathematics and broader scientific contexts. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
